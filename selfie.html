<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="header.css">
    <link rel="stylesheet" href="selfie.css">


    <title>Webcam Button Demo</title>

</head>

<body>




    <div id="sticky-header">
        <div id="headline">
            <a href="index.html"><img src="assets/logo.svg" alt="Headline" id="selfie-logo"></a>
        </div>
    </div>
    <div>
        <a href="gallery.html" class="back-btn">
            Back to gallery
        </a>






    </div>



    <div class="wrap">
        <h2>Capture your Silhouette</h2>

        <div class="controls">
            <button id="openBtn">Open camera</button>
            <button id="stopBtn" disabled>Stop</button>
            <button id="snapBtn" disabled>Capture photo</button>
            <label>
                Camera:
                <select id="deviceSelect"></select>
            </label>
        </div>

        <div class="row">
            <div>
                <video id="video" playsinline autoplay muted></video>
            </div>
            <div>
                <canvas id="canvas" width="640" height="480" hidden></canvas>
                <img id="preview" alt="Snapshot will appear here" />
                <div class="controls">
                    <a id="downloadLink" download="snapshot.png" hidden>Download sihouette</a>
                </div>

            </div>


        </div>
        <p class="selfie_directions">1. Open your camera.<br>2. Place your cursor over the "capture photo" button. <br>
            3. Turn your head to the side.<br>4. Look forward & click to capture your silhouette.
            <br><span style="font-style: italic;">Silhouette may take approximately one minute to process.</span>
        </p>
        <!-- <p class="note">
            Tip: This page must be served over <strong>HTTPS</strong> (or <code>http://localhost</code>) for the
            browser
            to allow camera access.
            On iOS/Safari, you must tap a button to start the camera.
        </p> -->
        <p id="error" class="error" role="alert" hidden></p>
    </div>

    <script>
        async function preload() {
            let Gradio = await import("https://cdn.jsdelivr.net/npm/@gradio/client/dist/index.min.js");
            mClient = await Gradio.Client.connect("arman396/Smithsonian"); console.log("Gradio client loaded", Gradio, mClient);
        }

        async function runFilter(imgBlob) {
            let input = {
                input_image: imgBlob,

            }

            let filterRes = await mClient.predict("/predict", input);
            return filterRes.data[0].url;
        }

        preload();

        const openBtn = document.getElementById('openBtn');
        const stopBtn = document.getElementById('stopBtn');
        const snapBtn = document.getElementById('snapBtn');
        const deviceSelect = document.getElementById('deviceSelect');
        // const video = document.getElementById('video');
        // const canvas = document.getElementById('canvas');
        const preview = document.getElementById('preview');
        const downloadLink = document.getElementById('downloadLink');
        const errorEl = document.getElementById('error');

        let currentStream = null;

        async function listDevices() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoInputs = devices.filter(d => d.kind === 'videoinput');
                deviceSelect.innerHTML = '';
                for (const d of videoInputs) {
                    const opt = document.createElement('option');
                    opt.value = d.deviceId;
                    opt.textContent = d.label || `Camera ${deviceSelect.length + 1}`;
                    deviceSelect.appendChild(opt);
                }
                if (videoInputs.length === 0) {
                    deviceSelect.innerHTML = '<option value="">No camera found</option>';
                }
            } catch (err) {
                showError(err);
            }
        }

        async function openCamera() {
            clearError();
            try {
                // stop previous stream if any
                stopStream();

                const deviceId = deviceSelect.value || undefined;
                const constraints = {
                    video: deviceId ? { deviceId: { exact: deviceId } } : { facingMode: 'user' },
                    audio: false
                };

                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                currentStream = stream;
                video.srcObject = stream;

                // Some browsers need play() to be awaited after setting srcObject
                await video.play();

                openBtn.disabled = true;
                stopBtn.disabled = false;
                snapBtn.disabled = false;

                // After getting permission once, labels become available
                await listDevices();
            } catch (err) {
                showError(err);
            }
        }

        function stopStream() {
            if (currentStream) {
                currentStream.getTracks().forEach(t => t.stop());
                currentStream = null;
            }
            video.srcObject = null;
            openBtn.disabled = false;
            stopBtn.disabled = true;
            snapBtn.disabled = true;
        }

        async function capturePhoto() {
            if (!currentStream) return;
            const track = currentStream.getVideoTracks()[0];
            const settings = track.getSettings();
            const w = settings.width || 640;
            const h = settings.height || 480;
            canvas.width = w; canvas.height = h;

            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0, w, h);
            const dataUrl = canvas.toDataURL('image/png');
            preview.src = dataUrl;
            const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png')); console.log('Captured photo blob:', blob);
            const modifiedBlob = await runFilter(blob); console.log('Modified blob:', modifiedBlob);
            preview.src = modifiedBlob;
            downloadLink.href = modifiedBlob;
            downloadLink.download = 'silhouette.webp';
            downloadLink.target = '_blank';
            downloadLink.hidden = false;
            downloadLink.textContent = 'Download silhouette';
        }

        function showError(err) {
            console.error(err);
            errorEl.hidden = false;
            errorEl.textContent = err?.message || String(err);
        }
        function clearError() { errorEl.hidden = true; errorEl.textContent = ''; }

        // Wire up events
        openBtn.addEventListener('click', openCamera);
        stopBtn.addEventListener('click', stopStream);
        snapBtn.addEventListener('click', capturePhoto);
        deviceSelect.addEventListener('change', () => { if (!openBtn.disabled) return; openCamera(); });

        // Populate device list early (labels may be blank until permission granted)
        if (navigator.mediaDevices?.enumerateDevices) {
            listDevices();
        }

        // Handle page unload
        window.addEventListener('beforeunload', stopStream);


        const fileInput = document.getElementById('fileInput');
        const canvas = document.getElementById('canvas');
        const video = document.getElementById('video'); // your video element
        const ctx = canvas.getContext('2d');

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    // Stop camera if running
                    if (video && video.srcObject) {
                        const stream = video.srcObject;
                        stream.getTracks().forEach(track => track.stop());
                        video.srcObject = null;
                    }

                    // Set canvas size to match image (or limit max size)
                    const maxWidth = 640;
                    const maxHeight = 480;
                    let width = img.width;
                    let height = img.height;

                    // Scale down if too large
                    if (width > maxWidth) {
                        height = (maxWidth / width) * height;
                        width = maxWidth;
                    }
                    if (height > maxHeight) {
                        width = (maxHeight / height) * width;
                        height = maxHeight;
                    }

                    canvas.width = width;
                    canvas.height = height;

                    // Draw uploaded image to canvas as preview
                    ctx.drawImage(img, 0, 0, width, height);

                    // Now the image is on canvas - you can apply filters/effects
                    // or let user snap/download this preview
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });
    </script>

</body>

</html>